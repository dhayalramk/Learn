- Link: https://www.tryexponent.com/blog/system-design-interview-guide
- Authors: [[Tom Lu]] , [[Neeraj Gupta]], [[Praveen Dubey]]
- Before starting this article, got doubt about [[HLD vs SLD]], so understood the basics
- Helpful tools to design: [[Tools / Whimsical]], [[Tools / Google Drawings]], [[Tools / Miro]]
- API Design Choices
	- Rest API
		- Properties: Resource Oriented, Data Driven, Flexible
		- Data: JSON, XML, YAML, HTML, Plain Text
		- Use Cases: Web based apps, cloud apps, client-server apps, cloud computing services, developer APIs
	- RPC
		- Properties: action-oriented, high performance
		- Data: JSON, XML, Thrift, Protobuf, FlatButters
		- Use Cases: complex microservice system, IoT Applications
	- GrapfQL
		- Properties: Single Endpoint, Strongly typed request, no data over fetching, self-documenting
		- Data: JSON
		- Use Cases: High performance mobile apps, complex systems and microservice based architectures
- Ways
	- Synchronous
		- Client -> (HTTP Sync) -> Service A's -> (HTTP Sync) -> Service B's
	- Async Messaging
		- Client -> (HTTP Sync) -> Service A's -> (Message) -> Queue -> (Message & Subscribe) -> Service B's
	- Publish - Subscribe
		- Client -> (HTTP Sync) -> Producer (Publish) -> Topic -> (Subscribe) -> Service A or Service B
- Scalability
	- [[HLD / Replication]]
		- Is the data important enough to make the copies? How important is it to keep the copies the same?
			- Active Data -> (Data Replication) -> Mirrored Data
	- [[HLD / Partitioning]]
		- Partition contains a subset of the whole table. Each partition is stored on a separate server.
			- Horizontal Partitioning -> N1, N2,.., Nx -> Vertical Partitioning
	- [[HLD / Sharding]]
		- Sharding allows a system to scale as data increases, but not all data is suitable for sharding.
			- Collection 1 -> [Shard 1, Shard 2, Shard 3, ..., Shard N]
	- [[HLD / Load Balancing]]
		- Load Balancing distributes incoming traffic across multiple servers or resources.
			- Upload Service -> Load Balancer -> [Image Processor, Image Processor, Image Processer]
- Notes:
	- G1
		- No. Items
		- Cache Miss & Hit
		- Disk & Memory Usage
	- G2
		- Write-Through
		- Read-Through
		- Write-Around
		- Write-Back
	- Popular caches:
		- In-memory
		- Redis
		- memcached
		- AWS Elasticcache
		- GCP Memorystore
	- Evictions:
		- LRU (Least Recently Used)
		- LFU (Least Freq. Used)
		- FIFO
		- MRU
		- Random Eviction
		- Least Used
		- On-Demand Expiration
		- Garbage Collections
	- G6
		- Storing user session
		- Communication between microservices
		- Caching frequent databases lookups
- Approach the problem
	- Step 1. Understanding the Problem - 10 Minutes
		- What are the fundamental and non-fundamental requirements?
		- What should be included and excluded?
		- Who are the clients and consumers?
		- Do you need to talk to pieces of an existing system?
		- Non functional requirements
			- Those may be related to business objectives or user experiences
			- includes
				- Availability
				- Consistency
				- Speed
				- Security
				- Reliability
				- Maintainablity
				- And Cost
			- To understand better from interviewer
				- What is the scale of the system?
				- How many users should it support?
				- How many requests should the server handle?
				- Are most use bases read-only?
				- Do users typically read the data shortly after someone else overwrites it?
				- Are most users on mobile devices?
			- Note:
				- If many design constrains, then focus on most critical one
					- Example: Social media design
						- Focus on photos and timeline generation services.
						- Lesser focus on: User registration and follow another user.
			- | Requirement     | Question                                                      |
			  |-----------------|---------------------------------------------------------------|
			  | Performance     | How fast is the system?                                       |
			  | Scalability     | How will the system respond to increased demand?              |
			  | Reliability     | What is the systemâ€™s uptime?                                  |
			  | Resilience      | How will the system recover if it fails?                      |
			  | Security        | How are the system and data protected?                        |
			  | Usability       | How do users interact with the system?                        |
			  | Maintainability | How will you troubleshoot the system?                         |
			  | Modifiability   | Can users customize features? Can developers change the code? |
			  | Localization    | Will the system handle currencies and languages?              |
		- Estimating Data
			- QPS (Queries Per Second)
			- Storage Size
			- Bandwidth requirement
	- Step 2: High-Level System Design - 10 Minutes
		-
	-
	-
	-